1. nested loops (重点关注驱动表的选择)
原理：
小表（驱动表，外部表），大表（内部表）
从小表中取一行，到大表中进行匹配，匹配到就output，
从小表中取第二行，......, 直至所有都output

优化：
小表连大表时，被驱动的大表是一个瓶颈，如果这张大表没有index，每次循环匹配性能会非常低，所以大表必须得有index。

一般小表（驱动表）采用全表扫描，大表（内部表）采用index（唯一索引，或高选择性的非唯一索引），驱动表越小，外层循环的次数也越小，效率也越高。

一般执行计划中NL第一个访问表就是驱动表（小表）

相比其他两种连接的区别：
1）.    基本不用内存，对底层IO负载高。
2）.    可以先返回已经连接的行，而不必等待所有的连接操作处理完才返回数据，这可以实现快速的响应时间。

hint控制：
/*+use_nl(t2,t) */，提示走nl, 没有指定驱动表
/*+ ordered use_nl(t2,t) */ 提示走nl，order指定以from后面的第一个表做为驱动表。
/*+ leading(t2) use_nl(t) */ 提示走nl，且t2为驱动表

select /*+ leading(emp) use_hash(emp,dept) use_nl(salgrade,bonus) */ 
from dept, emp,sqlgrade,bonus

2. sort merge （排序合并连接）
将2张表同时放入pga内存，按照连接列的值进行排序，然后排序后的结果根据where条件合并，提取符合条件的值。

内存中虽然可以提速，但是也耗内存，如果pga不够，会用到temp


3. hash join
原理：
也是小表连接大表的模式，小表（驱动表）通过hash函数，放到内存中，（大表不进内存）。
在内存中，把小表的每一行抽出来，和大表的hash函数得到的值一 一匹配，最后循环匹配处理。

特点：
只能用等值连接
